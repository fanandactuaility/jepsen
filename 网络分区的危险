这篇文章是关一些列网络分区的Jepsen的文章。我们将会学习分布式共识系统，讨论CAP理论的含义，演示不同数据库系统在网络分区下的表现。
现代软件系统由数十个通过异步，不可靠网络进行通信的组件组成。了解分布式系统动态的可靠性需要仔细分析网络本身。像计算机科学中最棘手的问题一样，这个问题归结为共享状态。由网络分离的一组节点必须交换信息：“我喜欢那个帖子吗？”“我的写作是否成功？”“你会缩略图我的形象吗？”“我的帐户有多少？
在其中一个请求结束时，您可能会保证所请求的操作...
  从现在开始，每个人都可以看到
  将会显示您的连接现在，其他人以后
  可能尚未见到，但与系统的某些未来状态有因果关系
  现在可见，但可能不会晚些
  可能或可能不可见：ERRNO_YOLO
这些是分布式系统中一致性和耐久性之间复杂相互作用的一些示例。例如，如果您将CRDT写入两个地理位置复制的Riak集群之一，W = 2和DW = 1，则可以保证写入...
  与系统的某些未来状态有因果关系
  将在一个节点的全部故障中生存
  将在所有节点的电源故障（假设fsync工作）之后生存
  将在整个数据中心的销毁后生存下来，给予几分钟的时间复制
如果你正在写的ZooKeeper，你可能有更强的一系列保障的：写可见现在对所有的参与者，例如，而且写会存活达N / 2的总失败- 1个节点。如果您写信给Postgres，根据您的交易的一致性级别，您可能可以保证每个人都可以看到这个写作，或者是“最终”。

在网络不可靠的情况下，这些保证是非常棘手的。

分区
分布式系统的正式证明通常假设网络是异步的，这意味着网络可能会在节点之间任意复制，丢弃，延迟或重新排序消息。这是一个微弱的假设：一些物理网络可以做得比这更好，但在实际中，IP网络将遇到所有这些故障模式，因此异步网络的理论局限性也适用于现实系统。
在实践中，TCP状态机允许节点订购节点之间的消息的递送重构“可靠”。TCP套接字保证我们的消息将在没有丢弃，重复或重新排序的情况下到达。然而，仍然会有任意的延迟 - 这通常会导致分布式系统无限期地锁定。由于计算机具有有限的内存和延迟范围，我们引入超时，当期望的消息在给定的时间范围内未能到达时，它将关闭连接。read()对套接字的呼叫将简单地阻止，然后失败。
检测网络故障很困难。由于我们对其他节点的唯一知识通过网络，因此延迟与故障无法区分。这是网络分区的根本问题：延迟足够高以被认为是故障。当分区出现时，我们无法确定其他节点发生了什么：他们还活着吗？死？他们收到我们的消息吗？他们是否尝试回应？字面上没有人知道。当网络终于愈合时，我们将不得不重新建立连接，并尝试解决发生了什么 - 可能从不一致的状态恢复。
许多系统通过输入特殊的降级操作模式来处理分区。CAP定理告诉我们，我们可以具有一致性（在技术上，读写寄存器的线性化）或可用性（所有节点都可以继续处理请求），但不能两者兼而有之。更重要的是，很少有数据库接近CAP的理论局限性; 很多简单的删除数据。
在本系列中，我将演示一些真正的分布式系统在网络发生故障时的行为。我们将首先设置一个集群和一个简单的应用程序。在每个后续的文章中，我们将探讨为特定数据库编写的应用程序，以及该系统在分区下的行为。

设置集群
你可以在家里创建分区！对于这些演示，我将运行一个使用LXC虚拟化的Ubuntu 12.10机器的五个节点集群，但是可以使用真实的计算机，虚拟专用服务器，EC2等。我命名节点n1，n2，n3 ，n4和n5：将这些条目添加到/etc/hosts计算机上和每个节点本身可能是最简单的方法。
我们将需要为集群和客户端应用程序进行一些配置来测试其行为。您可以克隆http://github.com/aphyr/jepsen来跟踪。
要在集群中运行命令，我使用的是Salticid（http://github.com/aphyr/salticid）。我已经~/.salticidrc指定了在杰普森回购中的配置：
  load ENV['HOME'] + '/jepsen/salticid/*.rb'

如果你看这个文件，你会看到它定义了一个名为“ :jepsenn1 ... n5”的组。每个节点的用户和密码是“ubuntu” - 如果您在公共网络上运行节点，您可能需要更改此设置。

尝试salticid -s salticid查看当前配置定义的所有组，主机和角色：

$ salticid -s salticid
Groups
  jepsen

Hosts:
  n1
  n2
  n3
  n4
  n5

Roles
  base
  riak
  mongo
  redis
  postgres
  jepsen
  net

Top-level tasks
首先，我们用一些常见的软件编译器，网络工具等来设置这些节点。
  salticid base.setup
该base角色定义了一些基本的操作系统功能。base.reboot将重新启动集群，base.shutdown并将取消该功能。

该jepsen角色定义了模拟网络故障的任务。要导致分区，运行salticid jepsen.partition。该命令导致节点n1和n2从n3，n4和n5基本上通过运行而丢弃IP流量

iptables -A INPUT -s n3 -j DROP
iptables -A INPUT -s n4 -j DROP
iptables -A INPUT -s n5 -j DROP

就这样，真的。要检查当前的网络状态，请运行jepsen.status。 jepsen.heal将iptables链复位为默认值，解析分区。

为了模拟慢速网络或丢弃数据包的网络，我们可以使用tc以调整以太网接口。Jepsen假设节点间接口是eth0。salticid jepsen.slow将增加网络的延迟，使得更容易重现依赖于特定消息被丢弃的错误。 salticid jepsen.flaky将概率地删除消息。调整节点间延迟和有效性可以模拟现实网络在拥塞状态下的行为，并有助于在分布式算法（如数据库复制）中公开时序相关性。


一个简单的分布式系统

为了测试一个分布式系统，我们需要一个工作负载 - 一组客户端，提出请求并记录其结果进行分析。对于这些帖子，我们将使用一个简单的应用程序，将多个数字写入数据库中的列表。每个客户端应用程序将独立地向DB写入一些整数。有五个客户端，客户端0写入0，5，10，15，...; 客户端1写入1，6，11，依此类推。

对于每个写入，我们记录数据库是否成功确认写入是否有错误。在运行结束时，我们要求数据库为全套。如果确认的写入丢失或未确认的写入存在，我们知道系统在某种程度上是不一致的：客户机应用程序和数据库不同意系统的状态。

在这一系列博客文章中，我们将针对多个分布式数据库运行此应用程序，并在其运行期间导致分区。在每种情况下，我们将看到系统如何响应丢弃的消息的不确定性。歌曲可能会去：

我在Clojure中编写了这个工作负载的几个实现。jepsen/src/jepsen/set_app.clj定义应用程序。(defprotocol SetApp ...)列出应用程序必须实现的功能，并(run n apps)设置应用程序并行运行，收集结果，并显示任何不一致。特定的实现方式居住在src/jepsen/riak.clj，pg.clj,redis.clj`等等。

您需要一个JVM和Leiningen 2才能运行此代码。一旦你安装了lein，并把它添加到你的路径，我们准备好了！

接下来在Jepsen，我们来看看Postgresql的事务协议如何处理网络故障。
